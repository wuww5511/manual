写在最前面：**个人认为，设计模式是为了应对需求的变更，便于代码的复用。如果确定一个模块的功能不会变化，也不需要复用，那就随意啦~~**

###单一职责原则(Single Responsibility Principle)
**就一个类而言，应该仅有一个引起它变化的原因**

把多个不同的功能划分为一个职责。

每一个模块只能拥有一个职责。

职责的划分不应该只考虑根据功能之间的相关性，还要考虑引发功能变更的原因是否相同。



###开放-封闭原则(Open Closed Principle)
**软件实体（类，模块，函数等等）应该是可以扩展的，但是不可修改的**


模块应该依赖于抽象类而不是实体类。

将可能的变化抽象出来。

在我们最初编写代码时，假设变化不会发生。当变化发生时，我们将创建抽象来隔离以后发生的同类变化。

###里氏替换原则(Liskov Substitutetution Princeiple)

**子类型必须能够替换掉它们的基类型**

子类的成员函数需要基于契约设计，即所有子类的相同成员函数需要满足同样的前置条件和后置条件。

当子类不能够满足LSP原则的时候，可以考虑抽离出公共部分，而不是继承。

###依赖倒置原则(DIP)

**高层模块不应该依赖于低层模块，二者都应该依赖于抽象**
**抽象不应该依赖于细节，细节应该依赖于抽象**

每一个高层模块都会为它所需要的服务声明一个抽象接口

